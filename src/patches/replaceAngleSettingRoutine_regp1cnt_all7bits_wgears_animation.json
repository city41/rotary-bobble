[
	{
		"patchDescription": "Replaces the p1 shooter angle setting routine with a value derived from p2 input"
	},
	{
		"description": "Replaces the routine",
		"address": "2f602",
		"patchAsm": [
			"move.l A4,D0 ; save A4, as the game needs it",

			"; save last frame's angle off in memory",
			"movea.l #$108262,A4",
			"move.w (A4),$108582",

			"; if reading REG_P1CNT directly, low is active. But the BIOS flips the bits for us",
			"movea.l #$10fd96,A4 ; load BIOS_P1CURRENT into A4",
			"move.l #0,D1 ; make sure D1 is totally zeroed",
			"move.b (A4),D1 ; read the current state of p1 input into D1",
			"move.l #0,D2 ; ensure d2 is zeroed",
			"move.b d1,d2 ; copy d1 (the input) into d2",
			"move.b d1,d5 ; copy d1 (the input) into d5 for the later negation",

			"move.b #$7f,d4 ; load d4 up for (input & 0x7f)",
			"and.b d4,d2 ; do (input & 0x7f) to clear D",

			"lsr.b #5,d2 ; shift the input down by 5 to get BC",
			"lsl.b #4,d2 ; bring CB into the upper bits of the byte",

			"move.l #$0000000f,d3 ; load 0x0000000f into d3 for the and instruction",
			"and.w d3,d1 ; clear out the top 28 bits, leaving RLDU in the bottom 4",
			"add.b d2,d1 ; add CB onto RLDU, arriving at the positive angle up to 63",

			"cmpi.b #60, D1 ; compare D1 to 60",
			"ble.s skipUpperClamp ; is it less than 60? no need to apply upper clamp",
			"move.b #60, D1 ; it is too big, clamp it down to 60",
			"skipUpperClamp:",

			"; at this point D1 is (0,60), ie positive angles, and d5 is the original input",
			"; if D was set, that means we want to negate the angle to (-60,0)",

			"lsr.b #7,D5 ; get D as the last bit",
			"cmpi.b #1,d5 ; compare d5 to 1",
			"bne skipNegation; d was not one? no negation asked for ",
			"muls.w #-1,d1 ; negation asked for, multiply angle by -1",
			"skipNegation:",

			"movea.l #$108262,A4 ; have A4 point to the angle memory address",
			"move.w D1,(A4) ; put D1 which is now (-60,60) as the angle",

			"; -----set direction of wheels and dino --------------------------;",
			"; ---- we set the dino direction in a new memory location, so that;",
			"; ---- setRotationSubroutine can then place it in the right spot -;",
			"; ---- at the right time -----------------------------------------;",
			"; compare to last frame's angle to get the sign",
			"sub.w $108582,D1 ; diff last frame's angle with this frame's angle",
			"beq.s setSignToZero",

			"ble.s skipPositiveSign",
			";;;;; move.w #1,$108212 ; our sign is 1, set it into the sign variable",
			"move.b #$8,$108584 ; also place the dino value to grab later",
			"bra doneWithSign ; we set sign, let's bail",

			"skipPositiveSign:",
			";;;;; move.w #-1,$108212 ; our sign is -1, set it into the sign variable",
			"move.b #$4,$108584 ; also place the dino value to grab later",
			"bra doneWithSign ; we set sign, let's bail",

			"setSignToZero:",
			";;;;; move.w #0,$108212 ; our fallback sign is 0, set it into the sign variable",
			"move.b #$0,$108584 ; also place the dino value to grab later",

			"doneWithSign:",

			"; --- now see if the player pressed A, if so, set 108585 to $10",
			"; --- the game is expecting 108285 to be $10 when A is pressed",

			";;;;; move.b $10fD97, D6 ; load BIOS_P1CHANGE into D6, going to see if A changed",
			";;;;; lsr.b #4,D6 ; get A as the last bit",
			";;;;; cmpi.b #1,d6 ; compare d6 to 1",
			";;;;; bne skipSetA; A was not just pressed? no need to do anthing",
			";;;;; move.b #$10, $108585 ; move $10 into our temporary location, so the other routine can grab it",

			";;;;; skipSetA:",
			"movea.l D0,A4 ; restore A4 as the game needs it",
			"rts"
		]
	}
]
