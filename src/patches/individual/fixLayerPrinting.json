[
	{
		"patchDescription": "Fix layer printing"
	},
	{
		"type": "prom",
		"description": "rotary version string",
		"string": true,
		"value": "rotary v0.0.1"
	},
	{
		"type": "prom",
		"description": "general string to fix layer routine",
		"subroutine": true,
		"patchAsm": [
			";;; this routine is called with A6 set to a base address with the following data",
			";;; [w:fix layer location][l: string pointer][w:countdown]",

			"move.w (A6), d7 ; load string's fix layer write location into d7",
			"movea.l $2(a6), a5 ; get this string's start address in ROM",
			"move.w $6(a6), d6 ; get the countdown value",

			"cmpi.w #0, d6 ; is the countdown at zero? then nothing to do",
			"beq exit",

			"move.w #32, $3c0004 ; set vrammod so that when writing to fix we write horizontally",
			"move.w d7, $3c0000 ; set this string's fix layer write location",

			"setAChar:",
			"clr.w d7 ; get d7 ready to hold the tile index, which is bigger than a byte",
			"move.b (a5), d7 ; grab a byte of the string into d7",
			"beq stringDone ; hit the null byte? then we are done",
			"adda.l #1, a5 ; increment to next byte, note: +(a5) would increment by a word",
			"cmpi.w #1, d6 ; is the counter at 1? that means erase the string, at zero we won't come in here at all",
			"beq useEmptyTile",
			"addi.w #768, d7 ; offset from ascii to fix tile index, this is specific to puzzle bobble's s-rom",
			"bra setTile",
			"useEmptyTile:",
			"move.w #$ff, d7 ; $ff is a blank tile used for erasing on the fix layer",
			"setTile:",
			"move.w d7, $3c0002 ; load the tile into the fix layer",
			"bra setAChar ; circle back up and do it again for the next letter",
			"stringDone:",
			"subi.w #1, d6 ; decrement the counter",
			"move.w d6, $6(a6) ; stick the counter back in memory",

			"exit:",
			"rts"
		]
	},
	{
		"type": "prom",
		"description": "string manager routine",
		"address": "f8e",
		"subroutine": true,
		"patchAsm": [
			"jsr $1da6 ; jump to the original routine we just clobbered the call of",

			";;;; game needs A6, so we need to save it",
			"move.l A6, D7",
			"move.l D7, $108dce",
			";;;; game needs A5, so we need to save it",
			"move.l A5, D7",
			"move.l D7, $108dca",

			"lea $108dd2, A6 ; load the version string (ie 'Rotary version a.b.c') base address",
			"jsr $7ff9c; jump to the general string routine to put it on screen",

			"lea $108dda, A6 ; load the p1 control toggle string (ie either 'rotary' or 'joystick')",
			"jsr $7ff9c; jump to the general string routine",

			"lea $108eda, A6 ; load the p2 control toggle string (ie either 'rotary' or 'joystick')",
			"jsr $7ff9c; jump to the general string routine",

			";;;; game needs A6, so restore it",
			"move.l $108dce, D7",
			"movea.l D7, A6",
			";;;; game needs A5, so restore it",
			"move.l $108dca, D7",
			"movea.l D7, A5",
			"rts"
		]
	},
	{
		"type": "prom",
		"description": "hook in the version string (ie 'Rotary version a.b.c') info early at game start",
		"address": "69a",
		"subroutine": true,
		"patchAsm": [
			";;; do what was just clobbered for the jts",
			"move.b #1, $10fdaf ; set BIOS_USE_MODE to 'Title'",

			";;; set up the version string values for the general string routine",
			";;; [w:fix layer location][l: string pointer][w:countdown]",
			"move.w #$7322, $108dd2 ; set up the version string's fix write location",
			"move.l #$7fff2, $108dd4 ; set up the pointer to the version string",
			"move.w #300, $108dd8 ; set its countdown",
			"rts"
		]
	},
	{
		"type": "prom",
		"description": "clean up the bytes left behind by the jsr",
		"address": "6a0",
		"patchAsm": ["nop"]
	}
]
