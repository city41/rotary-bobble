[
	{
		"patchDescription": "Replaces the p1 shooter angle setting routine with a value derived from p2 input"
	},
	{
		"description": "Replaces the routine",
		"address": "2f602",
		"patchAsm": [
			"move.l A4,D0 ; save A4, as the game needs it",
			"movea.l #$300000,A4 ; load REG_P2CNT into A4",
			"move.l #0,D1 ; make sure D1 is totally zeroed",
			"move.b (A4),D1 ; read the current state of p1 input into D1",
			"not.b D1 ; flip the input, as low is active",
			"move.l #0,D2 ; ensure d2 is zeroed",
			"move.b d1,d2 ; copy d1 (the input) into d2",
			"move.b d1,d5 ; copy d1 (the input) into d5 for the later negation",

			"move.b #$7f,d4 ; load d4 up for (input & 0x7f)",
			"and.b d4,d2 ; do (input & 0x7f) to clear D",

			"lsr.b #5,d2 ; shift the input down by 5 to get BC",
			"lsl.b #4,d2 ; bring CB into the upper bits of the byte",

			"move.l #$0000000f,d3 ; load 0x0000000f into d3 for the and instruction",
			"and.w d3,d1 ; clear out the top 28 bits, leaving RLDU in the bottom 4",
			"add.b d2,d1 ; add CB onto RLDU, arriving at the positive angle up to 63",

			"cmpi.b #60, D1 ; compare D1 to 60",
			"ble.s skipUpperClamp ; is it less than 60? no need to apply upper clamp",
			"move.b #60, D1 ; it is too big, clamp it down to 60",
			"skipUpperClamp:",

			"; at this point D1 is (0,60), ie positive angles, and d5 is the original input",
			"; if D was set, that means we want to negate the angle to (-60,0)",

			"lsr.b #7,D5 ; get D as the last bit",
			"cmpi.b #1,d5 ; compare d5 to 1",
			"bne skipNegation; d was not one? no negation asked for ",
			"muls.w #-1,d1 ; negation asked for, multiply angle by -1",
			"skipNegation:",

			"movea.l #$108262,A4 ; have A4 point to the angle memory address",
			"move.w D1,(A4) ; put D1 which is now (-60,60) as the angle",

			"movea.l D0,A4 ; restore A4 as the game needs it",
			"rts"
		]
	}
]
